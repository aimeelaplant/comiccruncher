package comic

import (
	"fmt"
	"strconv"
	"time"
)

const (
	// disableSourcesSql is the SQL for disabling character sources.
	disableSourcesSQL = `
	UPDATE character_sources
	SET is_disabled = TRUE	
	WHERE character_id = ?
		AND is_disabled = false -- no need to reset ones already disabled
		AND vendor_name ILIKE ANY(ARRAY[%s]);`
	// mainSourcesSql is the SQL for setting main sources.
	mainSourcesSQL = `
	UPDATE character_sources
	SET is_main = TRUE	
	WHERE character_id = ?
		AND is_main = FALSE -- ignore ones already already set
		AND is_disabled = FALSE -- ignore disabled ones
		AND vendor_name NOT ILIKE ALL(ARRAY[%s])`
	// altSourcesSql is the sql for setting alternate sources.
	altSourcesSQL = `
	UPDATE character_sources
	SET is_main = FALSE
	WHERE character_id = ?
		AND is_main = TRUE -- ignore ones already already set
		AND is_disabled = FALSE -- ignore disabled ones
		AND vendor_name ILIKE ANY(ARRAY[%s])`
)

// PublisherServicer is the service interface for publishers.
type PublisherServicer interface {
	// Publisher gets a publisher by its slug.
	Publisher(slug PublisherSlug) (*Publisher, error)
}

// IssueServicer is the service interface for issues.
type IssueServicer interface {
	// Issues gets issues by their IDs.
	Issues(ids []IssueID, limit, offset int) ([]*Issue, error)
	// IssuesByVendor gets issues by their vendor IDs and vendor types.
	IssuesByVendor(vendorIds []string, vendorType VendorType, limit, offset int) ([]*Issue, error)
	// Creates an issue.
	Create(issue *Issue) error
	// CreateP ceates an issue from parameters.
	CreateP(
		vendorID, vendorPublisher, vendorSeriesName, vendorSeriesNumber string,
		pubDate, saleDate time.Time,
		isVariant, isMonthUncertain, isReprint bool,
		format Format) error
}

// CharacterServicer is the service interface for characters.
type CharacterServicer interface {
	// Creates a character
	Create(character *Character) error
	// Character gets a character by its slug.
	Character(slug CharacterSlug) (*Character, error)
	// Updates a character.
	Update(character *Character) error
	// UpdateAll updates all characters
	UpdateAll(characters []*Character) error
	// CharactersWithSources gets all the enabled characters who have sources.
	CharactersWithSources(slug []CharacterSlug, limit, offset int) ([]*Character, error)
	// Characters gets all enabled characters by their slugs.
	Characters(slugs []CharacterSlug, limit, offset int) ([]*Character, error)
	// CharacterByVendor gets all the characters by the vendor. If `includeIsDisabled` is true, it will include disabled characters.
	CharacterByVendor(vendorID string, vendorType VendorType, includeIsDisabled bool) (*Character, error)
	// CharactersByPublisher list characters alphabetically. If `filterSources` is true, it will only list characters with sources.
	CharactersByPublisher(slugs []PublisherSlug, filterSources bool, limit, offset int) ([]*Character, error)
	// CreateSource creates a character source if it doesn't exist. If it exists, it returns the found source and an error.
	// And also modifies `source` to get the found values.
	CreateSource(source *CharacterSource) error
	// UpdateSource updates a character source
	UpdateSource(source *CharacterSource) error
	// MustNormalizeSources so that main vs alternate sources are categorized correctly and disables any unnecessary sources.
	// panics if there's an error.
	MustNormalizeSources(*Character)
	// Source gets a unique source by its character ID and vendor url.
	Source(id CharacterID, vendorURL string) (*CharacterSource, error)
	// Sources gets all the sources for a  character.
	Sources(id CharacterID, vendorType VendorType, isMain *bool) ([]*CharacterSource, error)
	// TotalSources gets the total sources for a character.
	TotalSources(id CharacterID) (int64, error)
	// CreateIssueP creates an issue for a character with the parameters.
	CreateIssueP(
		characterID CharacterID,
		issueID IssueID,
		appearanceType AppearanceType,
		importance *Importance) (*CharacterIssue, error)
	// CreateIssue creates an issue for a character.
	CreateIssue(issue *CharacterIssue) error
	// CreateIssues creates multiple issues for a character. // TODO: Autogenerated IDs not returned in struct!!
	CreateIssues(issues []*CharacterIssue) error
	// Issue gets a character issue by its character ID and issue ID
	Issue(characterID CharacterID, issueID IssueID) (*CharacterIssue, error)
	// CreateSyncLogP creates a sync log for a character with the parameters.
	CreateSyncLogP(
		id CharacterID,
		status CharacterSyncLogStatus,
		syncType CharacterSyncLogType,
		syncedAt *time.Time) (*CharacterSyncLog, error)
	// CreateSyncLog creates a sync log.
	CreateSyncLog(syncLog *CharacterSyncLog) error
	// UpdateSyncLog updates a sync log
	UpdateSyncLog(syncLog *CharacterSyncLog) error
	// BothAppearances gets the combined appearances for main + alternate
	BothAppearances(slug CharacterSlug) (AppearancesByYears, error)
	// ListAppearances gets main and alternate appearances as lists (so not combined)
	ListAppearances(slug CharacterSlug) ([]AppearancesByYears, error)
}

// RankedServicer is the interface for getting ranked and popular characters.
type RankedServicer interface {
	AllPopular(cr PopularCriteria) ([]*RankedCharacter, error)
	DCPopular(cr PopularCriteria) ([]*RankedCharacter, error)
	MarvelPopular(cr PopularCriteria) ([]*RankedCharacter, error)
	MarvelTrending(limit, offset int) ([]*RankedCharacter, error)
	DCTrending(limit, offset int) ([]*RankedCharacter, error)
}

// ExpandedServicer is the interface for getting a character with expanded details.
type ExpandedServicer interface {
	Character(slug CharacterSlug) (*ExpandedCharacter, error)
}

// ExpandedService gets an expanded character.
type ExpandedService struct {
	cr  CharacterRepository
	ar  AppearancesByYearsRepository
	r   RedisClient
	slr CharacterSyncLogRepository
}

// RankedService is the service for getting ranked and popular characters.
type RankedService struct {
	popRepo PopularRepository
	cr      CharacterRepository
	ar      AppearancesByYearsRepository
	r       RedisClient
}

// Character gets an expanded character.
func (s *ExpandedService) Character(slug CharacterSlug) (*ExpandedCharacter, error) {
	c, err := s.cr.FindBySlug(slug, false)
	if c == nil || err != nil {
		return nil, err
	}
	sl, err := s.slr.LastSyncs(c.ID)
	if err != nil {
		return nil, err
	}
	res, err := s.r.HGetAll(fmt.Sprintf("%s:stats", slug.Value())).Result()
	if err != nil {
		return nil, err
	}
	ec := &ExpandedCharacter{}
	if len(res) > 0 {
		atCount, err := parseUint(res["all_time_issue_count"])
		if err != nil {
			return nil, err
		}
		atRank, err := parseUint(res["all_time_issue_count_rank"])
		if err != nil {
			return nil, err
		}
		atAvg, err := strconv.ParseFloat(res["all_time_average_per_year"], 64)
		if err != nil {
			return nil, err
		}
		atAvgRank, err := parseUint(res["all_time_average_per_year_rank"])
		if err != nil {
			return nil, err
		}
		allTime := NewCharacterStats(AllTimeStats, atRank, atCount, atAvgRank, atAvg)
		miCount, err := parseUint(res["main_issue_count"])
		if err != nil {
			return nil, err
		}
		miRank, err := parseUint(res["main_issue_count_rank"])
		if err != nil {
			return nil, err
		}
		miAvgRank, err := parseUint(res["main_average_per_year_rank"])
		if err != nil {
			return nil, err
		}
		miAvg, err := strconv.ParseFloat(res["main_average_per_year"], 64)
		if err != nil {
			return nil, err
		}
		mainStats := NewCharacterStats(MainStats, miRank, miCount, miAvgRank, miAvg)
		stats := make([]CharacterStats, 2)
		stats[0] = allTime
		stats[1] = mainStats
		ec.Stats = stats
	}
	apps, err := s.ar.List(slug)
	if err != nil {
		return nil, err
	}
	ec.Appearances = apps
	ec.Character = c
	ec.LastSyncs = sl
	return ec, nil
}

// AllPopular gets the most popular characters per year ordered by either issue count or
// average appearances per year.
func (s *RankedService) AllPopular(cr PopularCriteria) ([]*RankedCharacter, error) {
	return s.popRepo.All(cr)
}

// DCPopular gets DC's most popular characters per year.
func (s *RankedService) DCPopular(cr PopularCriteria) ([]*RankedCharacter, error) {
	return s.popRepo.DC(cr)
}

// MarvelPopular gets Marvel's most popular characters per year ordered by either issue count o
// or average appearances per year.
func (s *RankedService) MarvelPopular(cr PopularCriteria) ([]*RankedCharacter, error) {
	return s.popRepo.Marvel(cr)
}

// MarvelTrending gets the trending characters for marvel.
func (s *RankedService) MarvelTrending(limit, offset int) ([]*RankedCharacter, error) {
	return s.popRepo.MarvelTrending(limit, offset)
}

// DCTrending gets the trending characters for marvel.
func (s *RankedService) DCTrending(limit, offset int) ([]*RankedCharacter, error) {
	return s.popRepo.DCTrending(limit, offset)
}

// PublisherService is the service for publishers.
type PublisherService struct {
	repository PublisherRepository
}

// IssueService is the service for issues.
type IssueService struct {
	repository IssueRepository
}

// CharacterService is the service for characters.
type CharacterService struct {
	repository            CharacterRepository
	issueRepository       CharacterIssueRepository
	sourceRepository      CharacterSourceRepository
	syncLogRepository     CharacterSyncLogRepository
	appearancesRepository AppearancesByYearsRepository
}

// Publisher gets a publisher by its slug.
func (s *PublisherService) Publisher(slug PublisherSlug) (*Publisher, error) {
	return s.repository.FindBySlug(slug)
}

// Issues gets all the issues by their IDs. A `limit` of `0` means no limit.
func (s *IssueService) Issues(ids []IssueID, limit, offset int) ([]*Issue, error) {
	return s.repository.FindAll(IssueCriteria{
		Ids:    ids,
		Limit:  limit,
		Offset: offset,
	})
}

// IssuesByVendor gets all the issues by the vendor IDs and vendor type.
// A limit of `0` means no limit.
func (s *IssueService) IssuesByVendor(ids []string, vendorType VendorType, limit, offset int) ([]*Issue, error) {
	return s.repository.FindAll(IssueCriteria{
		VendorIds:  ids,
		VendorType: vendorType,
		Limit:      limit,
		Offset:     offset,
	})
}

// Create creates an issue.
func (s *IssueService) Create(i *Issue) error {
	return s.repository.Create(i)
}

// CreateP Creates an issue from the parameters.
func (s *IssueService) CreateP(vendorID, vendorPublisher, vendorSeriesName, vendorSeriesNumber string, pubDate, saleDate time.Time, isVariant, isMonthUncertain, isReprint bool, format Format) error {
	return s.repository.Create(NewIssue(
		vendorID,
		vendorPublisher,
		vendorSeriesNumber,
		vendorSeriesNumber,
		pubDate,
		saleDate,
		isVariant,
		isMonthUncertain,
		isReprint,
		format,
	))
}

// Create creates a new character
func (s *CharacterService) Create(c *Character) error {
	return s.repository.Create(c)
}

// Character gets a non-disabled character by its slug.
func (s *CharacterService) Character(slug CharacterSlug) (*Character, error) {
	return s.repository.FindBySlug(slug, false)
}

// Update updates a character.
func (s *CharacterService) Update(c *Character) error {
	return s.repository.Update(c)
}

// UpdateAll updates all characters
func (s *CharacterService) UpdateAll(characters []*Character) error {
	return s.repository.UpdateAll(characters)
}

// CharactersWithSources gets non-disabled characters who have sources.
// A `limit` of `0` means unlimited.
func (s *CharacterService) CharactersWithSources(slugs []CharacterSlug, limit, offset int) ([]*Character, error) {
	return s.repository.FindAll(CharacterCriteria{
		Slugs:             slugs,
		IncludeIsDisabled: false,
		FilterSources:     true,
		Limit:             limit,
		Offset:            offset,
	})
}

// Characters gets all non-disabled characters by their slugs.
// A `limit` of `0` means unlimited.
func (s *CharacterService) Characters(slugs []CharacterSlug, limit, offset int) ([]*Character, error) {
	return s.repository.FindAll(CharacterCriteria{
		Slugs:             slugs,
		Limit:             limit,
		Offset:            offset,
		IncludeIsDisabled: false,
	})
}

// CreateSource creates a source for a character, if it doesn't exist.
// If it exists, an ErrAlreadyExists gets returned as an error.
// A little janky right now.
func (s *CharacterService) CreateSource(source *CharacterSource) error {
	err := s.sourceRepository.Create(source)
	return err
}

// UpdateSource updates an existing source
func (s *CharacterService) UpdateSource(source *CharacterSource) error {
	return s.sourceRepository.Update(source)
}

// Source gets a unique character source by its character ID and vendor url
func (s *CharacterService) Source(id CharacterID, vendorURL string) (*CharacterSource, error) {
	sources, err := s.sourceRepository.FindAll(CharacterSourceCriteria{
		CharacterIDs:      []CharacterID{id},
		IncludeIsDisabled: true,
		VendorUrls:        []string{vendorURL},
		Limit:             1,
	})
	if err != nil {
		return nil, err
	}
	if len(sources) == 0 {
		return nil, nil
	}
	return sources[0], nil
}

// Sources lists all non-disabled character sources from the given parameters.
// If `isMain` is `nil`, it will list both types of sources. If `isMain` is true, it will list main sources.
// If `isMain` is `false`, it will list alternate sources.
func (s *CharacterService) Sources(id CharacterID, vendorType VendorType, isMain *bool) ([]*CharacterSource, error) {
	return s.sourceRepository.FindAll(CharacterSourceCriteria{
		CharacterIDs:      []CharacterID{id},
		IncludeIsDisabled: false, // Don't include sources that are disabled!
		VendorType:        vendorType,
		IsMain:            isMain,
	})
}

// MustNormalizeSources normalizes sources for main and alternate sources and disables any unneeded sources.
func (s *CharacterService) MustNormalizeSources(c *Character) {
	id := c.ID.Value()
	var altUniverses []universeDefinition
	var disabledUniverses []universeDefinition
	if c.Publisher.Slug == "marvel" {
		altUniverses = marvelAltUniverses
		disabledUniverses = marvelDisabledUniverses
	} else if c.Publisher.Slug == "dc" {
		altUniverses = dcAltUniverses
		disabledUniverses = dcDisabledUniverses
	} else {
		panic(fmt.Sprintf("unknown publisher: %s", c.Publisher.Slug.Value()))
	}
	// todo: better to run all this in a transaction.
	// disable clones, impostors, etc.
	if !ignoreIDsForDisabled[id] {
		must(s.sourceRepository.Raw(fmt.Sprintf(disableSourcesSQL, pgSearchString(disabledUniverses)), id))
	}
	// set the main universes from alt universes.
	must(s.sourceRepository.Raw(fmt.Sprintf(mainSourcesSQL, pgSearchString(altUniverses)), id))
	// now set the alternate sources from alternate sources.
	// b/c if we add any more sources after running the above query, we
	// won't be able to set is_main = false for any of them. sooo stupid and i'm sure there's a better way to do this but whatever.
	must(s.sourceRepository.Raw(fmt.Sprintf(altSourcesSQL, pgSearchString(altUniverses)), id))
	// Now make sure earth-616 is set as main. (Some sources have 616 .. some don't. :( )
	if c.Publisher.Slug == "marvel" {
		must(s.sourceRepository.Raw("UPDATE character_sources SET is_main = TRUE WHERE vendor_name ILIKE '%earth-616)%' AND character_id = ?", id))
	}
}

// TotalSources gets the total number of sources for a character
func (s *CharacterService) TotalSources(id CharacterID) (int64, error) {
	return s.repository.Total(CharacterCriteria{FilterSources: true, IDs: []CharacterID{id}})
}

// CreateIssueP creates an issue from the parameters.
func (s *CharacterService) CreateIssueP(characterID CharacterID, issueID IssueID, appearanceType AppearanceType, importance *Importance) (*CharacterIssue, error) {
	issue := &CharacterIssue{
		CharacterID:    characterID,
		IssueID:        issueID,
		AppearanceType: appearanceType,
		Importance:     importance,
	}
	err := s.issueRepository.Create(issue)
	return issue, err
}

// CreateIssue creates an issue.
func (s *CharacterService) CreateIssue(issue *CharacterIssue) error {
	return s.issueRepository.Create(issue)
}

// CreateIssues creates multiple issues in a bulk query. TODO: Generated ID doesn't get set!
func (s *CharacterService) CreateIssues(issues []*CharacterIssue) error {
	return s.issueRepository.InsertFast(issues)
}

// Issue gets a character issue by its character ID and issue ID.
func (s *CharacterService) Issue(characterID CharacterID, issueID IssueID) (*CharacterIssue, error) {
	return s.issueRepository.FindOneBy(characterID, issueID)
}

// CreateSyncLogP creates a sync log with the parameters.
func (s *CharacterService) CreateSyncLogP(id CharacterID, status CharacterSyncLogStatus, syncType CharacterSyncLogType, syncedAt *time.Time) (*CharacterSyncLog, error) {
	syncLog := &CharacterSyncLog{
		CharacterID: id,
		SyncStatus:  status,
		SyncType:    syncType,
		SyncedAt:    syncedAt,
	}
	err := s.syncLogRepository.Create(syncLog)
	return syncLog, err
}

// CreateSyncLog creates a sync log for a character.
func (s *CharacterService) CreateSyncLog(syncLog *CharacterSyncLog) error {
	return s.syncLogRepository.Create(syncLog)
}

// UpdateSyncLog updates a sync log for a character.
func (s *CharacterService) UpdateSyncLog(syncLog *CharacterSyncLog) error {
	return s.syncLogRepository.Update(syncLog)
}

// CharacterByVendor gets a character from the specified vendor and whether the character is disabled or not.
func (s *CharacterService) CharacterByVendor(vendorID string, vendorType VendorType, includeIsDisabled bool) (*Character, error) {
	characters, err := s.repository.FindAll(CharacterCriteria{
		VendorIds:         []string{vendorID},
		VendorTypes:       []VendorType{vendorType},
		Limit:             1,
		IncludeIsDisabled: includeIsDisabled,
	})
	if err != nil {
		return nil, err
	}
	if len(characters) > 0 {
		return characters[0], nil
	}
	return nil, nil
}

// CharactersByPublisher lists enabled characters by their publisher.
func (s *CharacterService) CharactersByPublisher(slugs []PublisherSlug, filterSources bool, limit, offset int) ([]*Character, error) {
	return s.repository.FindAll(CharacterCriteria{
		FilterSources:     filterSources,
		PublisherSlugs:    slugs,
		IncludeIsDisabled: false,
		Limit:             limit,
		Offset:            offset,
	})
}

// BothAppearances lists the combination of main + alt appearances in one struct.
func (s *CharacterService) BothAppearances(slug CharacterSlug) (AppearancesByYears, error) {
	return s.appearancesRepository.Both(slug)
}

// ListAppearances lists both main and alternate appearances.
func (s *CharacterService) ListAppearances(slug CharacterSlug) ([]AppearancesByYears, error) {
	return s.appearancesRepository.List(slug)
}

// NewPublisherService creates a new publisher service
func NewPublisherService(container *PGRepositoryContainer) PublisherServicer {
	return &PublisherService{
		repository: container.PublisherRepository(),
	}
}

// NewCharacterService creates a new character service but with the appearances by years coming from postgres.
func NewCharacterService(container *PGRepositoryContainer) CharacterServicer {
	return &CharacterService{
		repository:            container.CharacterRepository(),
		issueRepository:       container.CharacterIssueRepository(),
		sourceRepository:      container.CharacterSourceRepository(),
		syncLogRepository:     container.CharacterSyncLogRepository(),
		appearancesRepository: container.AppearancesByYearsRepository(),
	}
}

// NewCharacterServiceWithCache creates a new character service but with the appearances by years coming from the Redis cache.
func NewCharacterServiceWithCache(container *PGRepositoryContainer, redis RedisClient) CharacterServicer {
	return &CharacterService{
		repository:            container.CharacterRepository(),
		issueRepository:       container.CharacterIssueRepository(),
		sourceRepository:      container.CharacterSourceRepository(),
		syncLogRepository:     container.CharacterSyncLogRepository(),
		appearancesRepository: NewRedisAppearancesPerYearRepository(redis),
	}
}

// NewIssueService creates a new issue service from the repository container.
func NewIssueService(container *PGRepositoryContainer) IssueServicer {
	return &IssueService{
		repository: container.IssueRepository(),
	}
}

// NewRankedService creates a new service for ranked characters.
func NewRankedService(repository PopularRepository) RankedServicer {
	return &RankedService{
		popRepo: repository,
	}
}

// NewExpandedService creates a new service for getting expanded details for a character
func NewExpandedService(cr CharacterRepository, ar AppearancesByYearsRepository, rc RedisClient, slr CharacterSyncLogRepository) ExpandedServicer {
	return &ExpandedService{
		cr:  cr,
		ar:  ar,
		r:   rc,
		slr: slr,
	}
}

func parseUint(s string) (uint, error) {
	u, err := strconv.ParseUint(s, 10, 64)
	return uint(u), err
}
