package comic

import (
	"errors"
	"time"
	"github.com/go-redis/redis"
)

var (
	ErrAlreadyExists = errors.New("the object already exists")
)

// The service interface for publishers.
type PublisherServicer interface {
	// Gets a publisher by its slug.
	Publisher(slug PublisherSlug) (*Publisher, error)
}

// The service interface for issues.
type IssueServicer interface {
	// Gets issues by their IDs.
	Issues(ids []IssueID, limit, offset int) ([]*Issue, error)
	// Gets issues by their vendor IDs and vendor types.
	IssuesByVendor(vendorIds []string, vendorType VendorType, limit, offset int) ([]*Issue, error)
	// Creates an issue.
	Create(issue *Issue) error
	// Creates an issue from parameters.
	CreateP(
		vendorID,vendorPublisher, vendorSeriesName, vendorSeriesNumber string,
		pubDate, saleDate time.Time,
		isVariant, isMonthUncertain bool,
		format Format) error
}

// The service interface for characters.
type CharacterServicer interface {
	// Creates a character
	Create(character *Character) error
	// Gets a character by its slug.
	Character(slug CharacterSlug) (*Character, error)
	// Updates a character.
	Update(character *Character) error
	// Updates all characters
	UpdateAll(characters []*Character) error
	// Gets all the enabled characters who have sources.
	CharactersWithSources(slug []CharacterSlug, limit, offset int) ([]*Character, error)
	// Gets all enabled characters by their slugs.
	Characters(slugs []CharacterSlug, limit, offset int) ([]*Character, error)
	// Gets all the characters by the vendor. If `includeIsDisabled` is true, it will include disabled characters.
	CharacterByVendor(vendorID string, vendorType VendorType, includeIsDisabled bool) (*Character, error)
	// List characters alphabetically. If `filterSources` is true, it will only list characters with sources.
	CharactersByPublisher(slugs []PublisherSlug, filterSources bool,  limit, offset int) ([]*Character, error)
	// Creates a character source if it doesn't exist. If it exists, it returns the found source and an error.
	// And also modifies `source` to get the found values.
	CreateSourceIfNotExists(source *CharacterSource) (*CharacterSource, error)
	// Updates a character source
	UpdateSource(source *CharacterSource) error
	// Normalize sources so that main vs alternate sources are categorized correctly.
	NormalizeSources(id CharacterID) error
	// Gets all the sources for a  character.
	Sources(id CharacterID, vendorType VendorType, isMain *bool) ([]*CharacterSource, error)
	// Gets the total sources for a character.
	TotalSources(id CharacterID) (int64, error)
	// Creates an issue for a character with the parameters.
	CreateIssueP(
		characterID CharacterID,
		issueID IssueID,
		appearanceType AppearanceType,
		importance *Importance) (*CharacterIssue, error)
	// Creates an issue for a character.
	CreateIssue(issue *CharacterIssue) error
	// Creates multiple issues for a character. // TODO: Autogenerated IDs not returned in struct!!
	CreateIssues(issues []*CharacterIssue) error
	// Gets a character issue by its character ID and issue ID
	Issue(characterID CharacterID, issueID IssueID) (*CharacterIssue, error)
	// Creates a sync log for a character with the parameters.
	CreateSyncLogP(
		id CharacterID,
		status CharacterSyncLogStatus,
		syncType CharacterSyncLogType,
		syncedAt *time.Time) (*CharacterSyncLog, error)
	// Creates a sync log.
	CreateSyncLog(syncLog *CharacterSyncLog) error
	// Updates a sync log
	UpdateSyncLog(syncLog *CharacterSyncLog) error
	// Gets all the character's main appearances.
	MainAppearances(slug CharacterSlug) (AppearancesByYears, error)
	// Gets all the character's alternate apppearances.
	AlternateAppearances(slug CharacterSlug) (AppearancesByYears, error)
	// Gets the combined appearances for main + alternate
	BothAppearances(slug CharacterSlug) (AppearancesByYears, error)
	// Gets main and alternate appearances as lists (so not combined)
	ListAppearances(slug CharacterSlug) ([]AppearancesByYears, error)
}

// The service for publishers.
type PublisherService struct {
	repository PublisherRepository
}

// The service for issues.
type IssueService struct {
	repository IssueRepository
}

// The service for characters.
type CharacterService struct {
	repository CharacterRepository
	issueRepository CharacterIssueRepository
	sourceRepository CharacterSourceRepository
	syncLogRepository CharacterSyncLogRepository
	appearancesRepository AppearancesByYearsRepository
}

// Gets a publisher by its slug.
func (s *PublisherService) Publisher(slug PublisherSlug) (*Publisher, error) {
	return s.repository.FindBySlug(slug)
}

// Gets all the issues by their IDs. A `limit` of `0` means no limit.
func (s *IssueService) Issues(ids []IssueID, limit, offset int) ([]*Issue, error) {
	return s.repository.FindAll(IssueCriteria{
		Ids: ids,
		Limit: limit,
		Offset: offset,
	})
}

// Gets all the issues by the vendor IDs and vendor type.
// A limit of `0` means no limit.
func (s *IssueService) IssuesByVendor(ids []string, vendorType VendorType, limit, offset int) ([]*Issue, error) {
	return s.repository.FindAll(IssueCriteria{
		VendorIds: ids,
		VendorType: vendorType,
		Limit: limit,
		Offset: offset,
	})
}

// Creates an issue.
func (s *IssueService) Create(i *Issue) error {
	return s.repository.Create(i)
}

// Creates an issue from the parameters.
func (s *IssueService) CreateP(vendorID, vendorPublisher, vendorSeriesName, vendorSeriesNumber string, pubDate, saleDate time.Time, isVariant, isMonthUncertain bool, format Format) error {
	return s.repository.Create(NewIssue(
		vendorID,
		vendorPublisher,
		vendorSeriesNumber,
		vendorSeriesNumber,
		pubDate,
		saleDate,
		isVariant,
		isMonthUncertain,
		format,
	))
}

// Creates a new character
func (s *CharacterService) Create(c *Character) error {
	return s.repository.Create(c)
}

// Gets a non-disabled character by its slug.
func (s *CharacterService) Character(slug CharacterSlug) (*Character, error) {
	return s.repository.FindBySlug(slug, false)
}

// Updates a character.
func (s *CharacterService) Update(c *Character) error {
	return s.repository.Update(c)
}

// Updates all characters
func (s *CharacterService) UpdateAll(characters []*Character) error {
	return s.repository.UpdateAll(characters)
}

// Gets non-disabled characters who have sources.
// A `limit` of `0` means unlimited.
func (s *CharacterService) CharactersWithSources(slugs []CharacterSlug, limit, offset int) ([]*Character, error) {
	return s.repository.FindAll(CharacterCriteria{
		Slugs: slugs,
		IncludeIsDisabled: false,
		FilterSources: true,
		Limit: limit,
		Offset: offset,
	})
}

// Gets all non-disabled characters by their slugs.
// A `limit` of `0` means unlimited.
func (s *CharacterService) Characters(slugs []CharacterSlug, limit, offset int) ([]*Character, error) {
	return s.repository.FindAll(CharacterCriteria{
		Slugs: slugs,
		Limit: limit,
		Offset: offset,
		IncludeIsDisabled: false,
	})
}

// Creates a source for a character, if it doesn't exist.
// If it exists, an ErrAlreadyExists gets returned as an error.
// A little janky right now.
func (s *CharacterService) CreateSourceIfNotExists(source *CharacterSource) (*CharacterSource, error) {
	if sources, err := s.sourceRepository.FindAll(CharacterSourceCriteria{
		CharacterIDs:      []CharacterID{source.CharacterID},
		VendorUrls:        []string{source.VendorUrl},
		VendorType:        source.VendorType,
		IncludeIsDisabled: true, // We want to include this so we don't create it again
		Limit:             1,
	}); err != nil {
		return nil, err
	} else if len(sources) > 0 {
		return sources[0], ErrAlreadyExists
	} else {
		err := s.sourceRepository.Create(source)
		return source, err
	}
}

// Updates an existing source
func (s *CharacterService) UpdateSource(source *CharacterSource) error {
	return s.sourceRepository.Update(source)
}

// Lists all non-disabled character sources from the given parameters.
// If `isMain` is `nil`, it will list both types of sources. If `isMain` is true, it will list main sources.
// If `isMain` is `false`, it will list alternate sources.
func (s *CharacterService) Sources(id CharacterID, vendorType VendorType, isMain *bool) ([]*CharacterSource, error) {
	return s.sourceRepository.FindAll(CharacterSourceCriteria{
		CharacterIDs:      []CharacterID{id},
		IncludeIsDisabled: false, // Don't include sources that are disabled!
		VendorType:        vendorType,
		IsMain: isMain,
	})
}

// Normalize sources for main and alternate sources.
func (s *CharacterService) NormalizeSources(id CharacterID) error {
	err := s.sourceRepository.Raw( `
		UPDATE character_sources cs
		SET is_main = TRUE	
		FROM characters c
		WHERE c.id = cs.character_id
		  AND c.id = ?
		  AND c.publisher_id = 1
		  AND cs.is_disabled = FALSE
		  AND cs.vendor_name NOT ILIKE ALL(ARRAY[
			'%616%',
			'%earth-%',
			'%2020%',
			'%2099%',
			'%26th Century%'
			'%Agent of Hydra%',
			'%100th Anniversary%',
			'%A-Babies%',
			'%(Marvel)(Adventures)%',
			'%Animated%',
			'%Cancerverse%',
			'%Earth X%',
			'%Bullet Points%',
			'%Undead%',
			'%Knowhere%',
			'%Mangaverse%',
			'%Mini Marvels%',
			'%Movies%',
			'%Noir%',
			'%Last Gun on Earth%',
			'%Super Hero Squad%',
			'%Next Avengers%',
			'%Timeslip%',
			'%Ultimate%',
			'%MC2%',
			'%Mutant X%',
			'%20xx%',
			'%(Marvel)(Spider-Gwen)%',
			'%Battle of the Atom%',
			'%E is for Extincti%',
			'%Exiles%',
			'%Vampire%',
			'%Egyptia%',
			'%(Marvel)(Forward)%',
			'%Old Man Logan%',
			'%Old Woman Laura%',
			'%X-Campus%',
			'%(Secret War)(Limbo)%',
			'%Age Of Apocalypse%',
			'%Age of Ultron%',
			'%Apes%',
			'%Age of X%',
			'%venomverse%',
			'%India%',
			'%Mitey ''vengers%',
			'%2211%',
			'%X-Men The End%',
			'%1872%',
			'%1602%',
			'%Inferno%',
			'%Mutopia%',
			'%2055%',
			'%Babies%',
			'%Mojoverse%',
			'%Killville%',
			'%What If%',
			'%Spider-Verse%',
			'%Shadow-X%',
			'%Days Of%',
			'%Omega World%',
			'%Killiseum%',
			'%imposter%',
			'%impostor%',
			'%mutate%',
			'%clone%',
			'%zombie%',
			'%a-force%',
			'%1,000,000 B.C.%',
			'%Guardians 3000%',
			'%Armor Wars%',
			'%Secret Wars%',
			'%Future Imperfect%',
			'%Dystopia%',
			'%Children''s Crusade Future%',
			'%X-Tinction Agenda%',
			'%Renew Your Vow%',
			'%Hex-men%',
			'%scorched earth%',
			'%(Thors)%',
			'%(Heroes Reborn)%',
			'%Years of Future%',
			'%newuniversal%',
			'%spider-island%'
		]);`, id.Value())
	if err != nil {
		return err
	}
	err = s.sourceRepository.Raw(`
		UPDATE character_sources cs
		SET is_main = true
		FROM characters c	
		WHERE c.id = cs.character_id
          AND c.id = ?
		  AND c.publisher_id = 2
		  AND cs.is_disabled = FALSE
		  AND cs.vendor_name NOT ILIKE ALL(ARRAY[
			'%Animated Universe%',
			'%non-continuity%',
			'%Smallville%',
			'%Titans%',
			'%Li''l Gotham%',
			'%Nazi%',
			'%bombshells%',
			'%injustice%',
			'%Arkhamverse%',
			'%batman beyond%',
			'%Ame-Comi Universe%',
			'%Gotham by Gaslight%',
			'%Gotham City Garage%',
			'%Red Rain%',
			'%Batman ''66%',
			'%White Knight%',
			'%Arrowverse%',
			'%New Order%',
			'%Wonder Woman ''77%',
			'%One Million%',
			'%Contest of Champions%',
		  ]);`, id.Value())
	return err
}

// Gets the total number of sources for a character
func (s *CharacterService) TotalSources(id CharacterID) (int64, error) {
	return  s.repository.Total(CharacterCriteria{FilterSources: true, IDs: []CharacterID{id}})
}

// Creates an issue from the parameters.
func (s *CharacterService) CreateIssueP(characterID CharacterID, issueID IssueID, appearanceType AppearanceType, importance *Importance) (*CharacterIssue, error) {
	issue := &CharacterIssue{
		CharacterID: characterID,
		IssueID: issueID,
		AppearanceType: appearanceType,
		Importance: importance,
	}
	err := s.issueRepository.Create(issue)
	return issue, err
}

// Creates an issue.
func (s *CharacterService) CreateIssue(issue *CharacterIssue) error {
	return s.issueRepository.Create(issue)
}

// Creates multiple issues in a bulk query. TODO: Generated ID doesn't get set!
func (s *CharacterService) CreateIssues(issues []*CharacterIssue) error {
	return s.issueRepository.InsertFast(issues)
}

// Gets a character issue by its character ID and issue ID.
func (s *CharacterService) Issue(characterID CharacterID, issueID IssueID) (*CharacterIssue, error) {
	return s.issueRepository.FindOneBy(characterID, issueID)
}

// Creates a sync log with the parameters.
func (s *CharacterService) CreateSyncLogP(id CharacterID, status CharacterSyncLogStatus, syncType CharacterSyncLogType, syncedAt *time.Time) (*CharacterSyncLog, error) {
	syncLog := &CharacterSyncLog{
		CharacterID: id,
		SyncStatus: status,
		SyncType: syncType,
		SyncedAt: syncedAt,
	}
	err := s.syncLogRepository.Create(syncLog)
	return syncLog, err
}

// Creates a sync log for a character.
func (s *CharacterService) CreateSyncLog(syncLog *CharacterSyncLog) error {
	return s.syncLogRepository.Create(syncLog)
}

// Updates a sync log for a character.
func (s *CharacterService) UpdateSyncLog(syncLog *CharacterSyncLog) error {
	return s.syncLogRepository.Update(syncLog)
}

// Gets a character from the specified vendor and whether the character is disabled or not.
func (s *CharacterService) CharacterByVendor(vendorID string, vendorType VendorType, includeIsDisabled bool) (*Character, error) {
	if characters, err := s.repository.FindAll(CharacterCriteria{
		VendorIds:         []string{vendorID},
		VendorTypes:       []VendorType{vendorType},
		Limit:             1,
		IncludeIsDisabled: includeIsDisabled,
	}); err != nil {
		return nil, err
	} else {
		if len(characters) > 0 {
			return characters[0], nil
		}
	}
	return nil, nil
}

// Lists enabled characters by their publisher.
func (s *CharacterService) CharactersByPublisher(slugs []PublisherSlug, filterSources bool,  limit, offset int) ([]*Character, error) {
	return s.repository.FindAll(CharacterCriteria{
		FilterSources: filterSources,
		PublisherSlugs: slugs,
		IncludeIsDisabled: false,
		Limit: limit,
		Offset: offset,
	})
}

// Lists the main appearances for a character.
func (s *CharacterService) MainAppearances(slug CharacterSlug) (AppearancesByYears, error) {
	return s.appearancesRepository.Main(slug)
}

// Lists the alternate appearances for a character.
func (s *CharacterService) AlternateAppearances(slug CharacterSlug) (AppearancesByYears, error) {
	return s.appearancesRepository.Alternate(slug)
}

// Lists the combination of main + alt appearances in one struct.
func (s *CharacterService) BothAppearances(slug CharacterSlug) (AppearancesByYears, error) {
	 return s.appearancesRepository.Both(slug)
}

// Lists both main and alternate appearances.
func (s *CharacterService) ListAppearances(slug CharacterSlug) ([]AppearancesByYears, error) {
	apps := make([]AppearancesByYears, 0)
	if main, err := s.MainAppearances(slug); err != nil {
		return nil, err
	} else if main.CharacterSlug != "" {
		apps = append(apps, main)
	}
	if alt, err := s.AlternateAppearances(slug); err != nil {
		return nil, err
	} else if alt.CharacterSlug != ""  {
		apps = append(apps, alt)
	}
	return apps, nil
}

// Creates a new publisher service
func NewPublisherService(container *PGRepositoryContainer) PublisherServicer {
	return &PublisherService{
		repository: container.PublisherRepository(),
	}
}

// Creates a new character service but with the appearances by years coming from postgres.
func NewCharacterService(container *PGRepositoryContainer) CharacterServicer {
	return &CharacterService{
		repository: container.CharacterRepository(),
		issueRepository: container.CharacterIssueRepository(),
		sourceRepository: container.CharacterSourceRepository(),
		syncLogRepository: container.CharacterSyncLogRepository(),
		appearancesRepository: container.AppearancesByYearsRepository(),
	}
}

// Creates a new character service but with the appearances by years coming from the Redis cache.
func NewCharacterServiceWithCache(container *PGRepositoryContainer, redis *redis.Client) CharacterServicer {
	return &CharacterService{
		repository: container.CharacterRepository(),
		issueRepository: container.CharacterIssueRepository(),
		sourceRepository: container.CharacterSourceRepository(),
		syncLogRepository: container.CharacterSyncLogRepository(),
		appearancesRepository: NewRedisAppearancesPerYearRepository(redis),
	}
}

// Creates a new issue service from the repository container.
func NewIssueService(container *PGRepositoryContainer) IssueServicer {
	return &IssueService{
		repository: container.IssueRepository(),
	}
}
